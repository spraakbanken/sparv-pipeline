"""Snakefile used by Snakemake."""
import copy
import inspect
import os
import re

import snakemake
from snakemake.logging import logger

from sparv import util
from sparv.core import config as sparv_config
from sparv.core import paths, registry
from sparv.util.classes import *

# We have to wait until the configuration dict is complete until we load modules
registry.find_modules(paths.sparv_path)

# All output annotations available, used for printing a list
all_annotations = {}

# All named targets available, used in list_targets
named_targets = []
export_targets = []

# List which will contain all source files
source_files = []

# Remove Snakemake's default log handler
if config.get("run_by_sparv") and logger.log_handler and logger.log_handler[0] == logger.text_handler:
    logger.log_handler = []


def get_source_path() -> str:
    """Get path to source files."""
    return sparv_config.get("source_dir", paths.source_dir)


def get_annotation_path(annotation, data=False):
    """Construct a path to an annotation file given a doc and annotation."""
    elem, attr = util.split_annotation(annotation)

    if data:
        path = elem
    else:
        if not attr:
            attr = util.SPAN_ANNOTATION
        path = os.path.join(elem, attr)
    return "{doc}/" + path


def get_source_files() -> List[str]:
    """Get list of all available source files"""
    global source_files
    if not source_files:
        source_files = [f[1][0] for f in snakemake.utils.listfiles(
            os.path.join(get_source_path(), "{file}." + sparv_config.get("source_type", "xml")))]
    return source_files


def make_rule(module_name, f_name, desc, f, importer, exporter, source_type, import_outputs) -> None:
    """Build Snakemake rules."""
    # Build input, output and parameter list
    if config.get("debug"):
        print()
        print("{}{}:{} {}".format(util.Color.BOLD, module_name.upper(), util.Color.RESET, f_name))
        print()
    inputs = []
    outputs = []
    parameters = {}
    docs = []  # List of parameters refering to Document
    doc_annotations = []  # List of parameters containing the {doc} wildcard
    wildcard_annotations = []  # List of parameters containing other wildcards
    if importer:
        inputs.append(os.path.join(get_source_path(), "{doc}." + source_type))
        if source_type == sparv_config.get("source_type", "xml"):
            # Exports always generate corpus text file
            outputs.append(os.path.join(paths.annotation_dir, "{doc}", util.TEXT_FILE))
            # If importer guarantees other outputs, add them to outputs list
            if import_outputs:
                if isinstance(import_outputs, Config):
                    import_outputs = sparv_config.get(import_outputs)
                annotations_ = set()
                for annotation in import_outputs:
                    annotations_.add(annotation)
                    annotations_.add(util.split_annotation(annotation)[0])
                for element in annotations_:
                    outputs.append(os.path.join(paths.annotation_dir, get_annotation_path(element)))
    elif exporter:
        pass

    params = inspect.signature(f).parameters

    # Go though function parameters and handle based on type
    for param_name, param in params.items():
        # Output
        if isinstance(param.default, Output):
            param_value = registry.expand_variables(param.default)
            if param.default.all_docs:
                outputs.extend(expand(os.path.join(paths.annotation_dir, get_annotation_path(param_value,
                                                                                         data=param.default.data)),
                                      doc=get_source_files()))
            else:
                outputs.append(get_annotation_path(param_value, data=param.default.data))
            parameters[param_name] = param_value
            if "{" in param_value:
                wildcard_annotations.append(param_name)
            all_annotations.setdefault(module_name, {}).setdefault(f_name, {"description": desc, "annotations": []})
            all_annotations[module_name][f_name]["annotations"].append((param.default, param.default.description))
        # Annotation
        elif registry.dig(Annotation, param.default):
            param_value = registry.expand_variables(param.default)
            if exporter:
                if param.default.all_docs:
                    inputs.extend(expand(os.path.join(paths.annotation_dir, get_annotation_path(param_value,
                                                                                         data=param.default.data)),
                                         doc=get_source_files()))
                else:
                    inputs.append(os.path.join(paths.annotation_dir, get_annotation_path(param_value,
                                                                                         data=param.default.data)))
            else:
                inputs.append(get_annotation_path(param_value, data=param.default.data))

                # Add @text as requirement for all rules with non-data Annotation dependencies
                text_file = get_annotation_path(util.TEXT_FILE, data=True)
                if not param.default.data and not text_file in inputs:
                    inputs.append(text_file)
            parameters[param_name] = param_value
            if "{" in param_value:
                wildcard_annotations.append(param_name)
        # ExportAnnotations
        elif param.default == ExportAnnotations or isinstance(param.default, ExportAnnotations):
            parameters[param_name] = []
            export_annotations = sparv_config.get("annotations", [])
            for annotation in export_annotations:
                annotation, _, new_name = annotation.partition(" as ")
                param_value = registry.expand_variables(annotation)
                if param.default.is_input:
                    inputs.append(os.path.join(paths.annotation_dir, get_annotation_path(param_value)))
                if new_name:
                    param_value = " as ".join((param_value, new_name))
                parameters[param_name].append(param_value)
        # Corpus
        elif param.default == Corpus or isinstance(param.default, Corpus):
            parameters[param_name] = sparv_config.get("id")
        # Language
        elif param.default == Language or isinstance(param.default, Language):
            parameters[param_name] = sparv_config.get("language")
        # Document
        elif param.default == Document or isinstance(param.default, Document):
            docs.append(param_name)
        # AllDocuments (all source documents)
        elif registry.dig(AllDocuments, param.default):
            parameters[param_name] = get_source_files()
        # Model
        elif registry.dig(Model, param.default):
            if param.default is not None:
                if isinstance(param.default, Model):
                    model = paths.get_model_path(registry.expand_variables(param.default))
                    inputs.append(model)
                    parameters[param_name] = model
                elif isinstance(param.default, (list, tuple)):
                    parameters[param_name] = []
                    for model in param.default:
                        model = paths.get_model_path(registry.expand_variables(model))
                        inputs.append(model)
                        parameters[param_name].append(model)
        # Binary
        elif isinstance(param.default, Binary):
            binary = paths.get_bin_path(registry.expand_variables(param.default))
            inputs.append(binary)
            parameters[param_name] = binary
        # Source
        elif param.default == Source or isinstance(param.default, Source):
            parameters[param_name] = get_source_path()
        # Export
        elif param.default == Export or isinstance(param.default, Export):
            if param.default.absolute_path:
                parameters[param_name] = registry.expand_variables(param.default)
            else:
                parameters[param_name] = os.path.join(paths.export_dir, registry.expand_variables(param.default))
            outputs.append(parameters[param_name])
            if "{doc}" in parameters[param_name]:
                doc_annotations.append(param_name)
        # ExportInput
        elif isinstance(param.default, ExportInput):
            if param.default.absolute_path:
                parameters[param_name] = registry.expand_variables(param.default)
            else:
                parameters[param_name] = os.path.join(paths.export_dir, registry.expand_variables(param.default))
            if param.default.all_docs:
                inputs.extend(expand(parameters[param_name], doc=get_source_files()))
            else:
                inputs.append(parameters[param_name])
        # Config
        elif isinstance(param.default, Config):
            parameters[param_name] = sparv_config.get(param.default)
        # Everything else with a default value
        elif param.default is not None:
            parameters[param_name] = param.default

    if config.get("debug"):
        print("    " + util.Color.BOLD + "INPUTS" + util.Color.RESET)
        for i in inputs:
            print("        {}".format(i))
        print()
        print("    " + util.Color.BOLD + "OUTPUTS" + util.Color.RESET)
        for o in outputs:
            print("        {}".format(o))
        print()
        print("    " + util.Color.BOLD + "PARAMETERS" + util.Color.RESET)
        for p in parameters:
            print("        {} = {!r}".format(p, parameters[p]))
        print()
        print()

    def get_doc_value(wildcards):
        """Extract the {doc} part from full annotation path."""
        doc = None
        if hasattr(wildcards, "doc"):
            if importer or exporter:
                doc = wildcards.doc
            else:
                doc = wildcards.doc[len(paths.annotation_dir) + 1:]
        return doc

    def get_parameters(wildcards):
        """Extend function parameters with doc names and replace wildcards."""
        doc = get_doc_value(wildcards)
        # We need to make a copy of the parameters, since the rule might be used for multiple documents
        _parameters = copy.deepcopy(parameters)
        _parameters.update({name: doc for name in docs})

        # Replace {doc} wildcard in parameters
        for name in doc_annotations:
            _parameters[name] = _parameters[name].replace("{doc}", doc)

        # Replace wildcards in parameters
        for name in wildcard_annotations:
            wcs = re.finditer(r"{([^}]+)}", _parameters[name])
            for wc in wcs:
                _parameters[name] = _parameters[name].replace(wc.group(), wildcards.get(wc.group(1)))
        return _parameters

    rule:
        message:
            "{}:{}".format(module_name, f_name)
        input:
            inputs
        output:
            outputs
        params:
            module_name = module_name,
            f_name = f_name,
            parameters = get_parameters,
            log = config.get("log")
        script:
            "run_snake.py"
            # We don't use "run:" since the whole Snakefile would have to be reloaded for every single job, due to how
            # Snakemake creates processes for run-jobs.

    # Create rule to run this annotation on all input files, but skip rules containing wildcards
    if not any(re.search(r"(?!{doc}){[^}]+}", o) for o in outputs):
        target_name = module_name + ":" + f_name
        if exporter:
            export_targets.append((target_name, desc))
        else:
            named_targets.append((target_name, desc))
        @workflow.rule(name=target_name)
        @workflow.input(expand([os.path.join(paths.annotation_dir, o)
                                if not (o.startswith(paths.annotation_dir) or o.startswith(paths.export_dir))
                                else o
                                for o in outputs], doc=config.get("file") or get_source_files()))
        @workflow.run
        def __rule__(*_args, **_kwargs):
            pass


rule empty:
    shell:
        "echo"

# Find local corpus config
corpus_config_file = os.path.join(os.getcwd(), paths.config_file)
if not os.path.isfile(corpus_config_file):
    print("No corpus config file found.")
    corpus_config_file = None

# Read config file(s)
sparv_config.load_config(corpus_config_file)

registry.annotation_classes["config_classes"] = sparv_config.config.get("classes", {})

# Create rules for all available annotation functions
for module_name in registry.annotators:
    for f_name in registry.annotators[module_name]:
        f, desc, importer, exporter, source_type, outputs = registry.annotators[module_name][f_name]
        make_rule(module_name, f_name, desc, f, importer, exporter, source_type, outputs)

# Rule to list all config options and their current values
rule config:
    run:
        longest_key = max(len(key) for key in sparv_config.config) + 10
        for key, val in sorted(sparv_config.config.items()):
            print("{:{width}}{}".format(key + ":", str(val), width=longest_key))

rule annotations:
    run:
        max_len = max(len(a[0]) for m in all_annotations for f in all_annotations[m]
                      for a in all_annotations[m][f]["annotations"]) + 8
        print()
        print("Available modules, annotators and annotations")
        print("=============================================\n")
        for module_name in sorted(all_annotations):
            print(util.Color.BOLD + "{}".format(module_name.upper()) + util.Color.RESET)
            for f_name in sorted(all_annotations[module_name]):
                print("      {}{}{}".format(util.Color.UNDERLINE, f_name, util.Color.RESET))
                f_desc = all_annotations[module_name][f_name]["description"]
                if f_desc:
                    print("      {}".format(f_desc))
                print()
                f_anns = all_annotations[module_name][f_name]["annotations"]
                for f_ann in sorted(f_anns):
                    print("        â€¢ {:{width}}{}".format(f_ann[0], f_ann[1] or "", width=max_len))
                    if f_ann[0].cls:
                        print(util.Color.ITALIC + "          <{}>".format(f_ann[0].cls) + util.Color.RESET)
                print()
            print("\n")

        max_len = max(len(cls) for cls in registry.annotation_classes["module_classes"]) + 8

        print("Available classes")
        print("=================\n")
        print(util.Color.BOLD + "    Classes defined by pipeline modules"+ util.Color.RESET)
        print("        {}{:{}}    {}{}".format(util.Color.ITALIC, "Class", max_len, "Annotation", util.Color.RESET))
        for cls, anns in registry.annotation_classes["module_classes"].items():
            print("        {:{}}    {}".format(cls, max_len, anns[0]))
            if len(anns) > 1:
                for ann in anns[1:]:
                    print("        {:{}}    {}".format("", max_len, ann))

        if registry.annotation_classes["config_classes"]:
            print()
            print(util.Color.BOLD + "    Classes from config" + util.Color.RESET)
            print("        {}{:{}}    {}{}".format(util.Color.ITALIC, "Class", max_len, "Annotation", util.Color.RESET))
            for cls, ann in registry.annotation_classes["config_classes"].items():
                print("        {:{}}    {}".format(cls, max_len, ann))

rule list_targets:
    run:
        max_len = max(len(t[0]) for t in named_targets + export_targets) + 4
        print()
        print("Available targets")
        print("=================\n")
        print("    EXPORTS")
        for target, desc in sorted(export_targets):
            print("        {:{}}    {}".format(target, max_len, desc))
        print()
        print("    ANNOTATIONS")
        for target, desc in sorted(named_targets):
            print("        {:{}}    {}".format(target, max_len, desc))

rule files:
    # List all input files
    run:
        print("Available input files:\n")
        print(", ".join(get_source_files()))

rule clean:
    # Remove annotations dir
    run:
        # Only run if corpus config is found in same dir
        if corpus_config_file is None:
            print("No corpus config found. Not removing anything.")
        else:
            import shutil
            if config.get("export"):
                to_remove = paths.export_dir
                assert paths.export_dir, "Export dir name not configured."
            else:
                to_remove = paths.annotation_dir
                assert paths.annotation_dir, "Annotations dir name not configured."

            full_path = os.path.join(os.getcwd(), to_remove)
            if os.path.isdir(full_path):
                shutil.rmtree(full_path)
                print(to_remove, "directory removed")
            else:
                print("Nothing to remove")
